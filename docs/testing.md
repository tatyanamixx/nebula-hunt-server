# Тестирование в проекте NebulaHunt

## Обзор

Проект NebulaHunt использует Jest в качестве основного фреймворка для тестирования. Тесты разделены на две категории:

1. **Модульные тесты** - проверяют отдельные компоненты системы в изоляции
2. **Интеграционные тесты** - проверяют взаимодействие между компонентами

## Структура тестов

Тесты находятся в директории `tests/` и организованы по следующей структуре:

```
tests/
  ├── controllers/       # Тесты контроллеров
  ├── middlewares/       # Тесты промежуточного ПО
  ├── service/           # Тесты сервисов
  └── setup.js           # Общая настройка тестового окружения
```

## Настройка окружения

Файл `tests/setup.js` отвечает за настройку тестового окружения:

-   Подключение к тестовой базе данных (SQLite в памяти)
-   Условное выполнение миграций (только для интеграционных тестов)
-   Очистка таблиц между тестами
-   Закрытие соединения с базой после выполнения всех тестов

## Запуск тестов

В проекте настроены следующие скрипты для запуска тестов:

```bash
# Запуск всех тестов
npm test

# Запуск только модульных тестов (без миграций)
npm run test:unit

# Запуск только интеграционных тестов (с миграциями)
npm run test:integration

# Запуск тестов с отчетом о покрытии кода
npm run test:coverage
```

## Модульные тесты

Модульные тесты используют моки для изоляции тестируемого компонента от его зависимостей. Для этого используется функциональность Jest по мокированию модулей.

### Пример мокирования сервиса:

```javascript
// Мокаем зависимости
jest.mock('../../service/user-service');
const userService = require('../../service/user-service');

// Настраиваем поведение мока
userService.login.mockResolvedValue({
	user: { id: 123, username: 'test' },
	accessToken: 'test-token',
});
```

## Интеграционные тесты

Интеграционные тесты используют тестовую базу данных SQLite в памяти и выполняют миграции перед запуском тестов. Это позволяет проверить взаимодействие между компонентами системы.

Для запуска интеграционных тестов используется переменная окружения `RUN_MIGRATIONS=true`.

## Мокирование Sequelize

Для модульных тестов мы мокируем модели Sequelize следующим образом:

```javascript
jest.mock('../../models/models', () => {
	// Создаем моки для всех моделей
	const User = {
		findOne: jest.fn(),
		findByPk: jest.fn(),
		// другие методы...
	};

	return {
		User,
		// другие модели...
	};
});

// Получаем мокированные модели
const { User } = require('../../models/models');
```

## Мокирование транзакций

Для тестирования кода, использующего транзакции Sequelize, мы мокируем метод `transaction`:

```javascript
jest.mock('../../db', () => {
	// Создаем мок транзакции
	const mockTransaction = {
		commit: jest.fn().mockResolvedValue(true),
		rollback: jest.fn().mockResolvedValue(true),
		finished: false,
	};

	// Мокируем sequelize с методом transaction
	return {
		transaction: jest.fn().mockResolvedValue(mockTransaction),
	};
});
```

## Советы по написанию тестов

1. **Изолируйте тесты** - каждый тест должен быть независимым от других
2. **Используйте `beforeEach`** для настройки начального состояния перед каждым тестом
3. **Проверяйте граничные случаи** - тестируйте не только "счастливый путь", но и обработку ошибок
4. **Мокируйте внешние зависимости** - API, базы данных, файловую систему и т.д.
5. **Используйте описательные имена тестов** - тест должен ясно описывать, что он проверяет

## Решение распространенных проблем

### Проблема: Ошибка "Unrecognized datatype for attribute"

Эта ошибка возникает, когда мок модели не содержит всех необходимых полей или типов данных. Решение:

1. Убедитесь, что вы мокируете все необходимые методы модели
2. Для моделей с ENUM типами, убедитесь, что мок возвращает правильный тип данных

### Проблема: Ошибка "callback is not a function"

Эта ошибка возникает при неправильном мокировании транзакций. Решение:

```javascript
// Правильный мок для транзакций
jest.mock('../../db', () => {
	const mockTransaction = {
		commit: jest.fn().mockResolvedValue(true),
		rollback: jest.fn().mockResolvedValue(true),
		finished: false,
	};

	return {
		transaction: jest.fn().mockResolvedValue(mockTransaction),
	};
});
```

## Дополнительные ресурсы

-   [Документация Jest](https://jestjs.io/docs/getting-started)
-   [Руководство по тестированию Express](https://expressjs.com/en/advanced/best-practice-performance.html#do-logging-correctly)
-   [Тестирование Sequelize](https://sequelize.org/docs/v6/other-topics/test-cases/)
